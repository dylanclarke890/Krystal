float Shadows(
  vec4 lightFragmentPosition,
  vec3 tangentLightDirection,
  vec3 tangentNormal,
  sampler2D shadowMap
)
{
  vec3 projectionCoords = lightFragmentPosition.xyz / lightFragmentPosition.w; // perform perspective divide
  projectionCoords = projectionCoords * 0.5 + 0.5; // transform to [0,1] range
  if (projectionCoords.z > 1.0)
  {
    return 0.0;
  } 

  float closestDepth = texture(shadowMap, projectionCoords.xy).r; // get closest depth value from light's perspective
  float currentDepth = projectionCoords.z;

  float bias = max(0.05 * (1.0 - dot(tangentNormal, tangentLightDirection)), 0.005);
  vec2 texelSize = 1.0 / textureSize(shadowMap, 0);

  float shadow = 0.0;
  // PCF
  for (int x = -1; x <= 1; x++)
  {
    for (int y = -1; y <= 1; y++)
    {
      float pcfDepth = texture(shadowMap, projectionCoords.xy + vec2(x, y) * texelSize).r; 
      shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;        
    }    
  }

  shadow /= 9.0; // average the samples taken above
  return shadow;
}

vec3 Lighting(
  DirectionalLight light,
  vec4 lightFragmentPosition,
  vec3 tangentFragmentPosition,
  vec3 tangentCameraPosition,
  vec3 tangentLightDirection,
  vec3 tangentNormal,
  vec3 diffuseSample,
  vec3 specularSample,
  float shininess,
  sampler2D shadowMap,
  bool useBlinnLighting
)
{
  if (!light.Enabled)
  {
    return vec3(0.0);
  }

  tangentLightDirection = normalize(tangentLightDirection);

  vec3 ambient = vec3(light.Ambient) * diffuseSample;

  float diffuseFactor = max(dot(tangentNormal, tangentLightDirection), 0.0);
  vec3 diffuse = vec3(light.Diffuse) * diffuseFactor * diffuseSample;

  vec3 specular = Specular(
    tangentCameraPosition,
    tangentFragmentPosition,
    tangentLightDirection,
    tangentNormal,
    vec3(light.Specular),
    specularSample,
    shininess,
    useBlinnLighting
  );
  
  float shadow = Shadows(lightFragmentPosition, tangentLightDirection, tangentNormal, shadowMap);
  
  return (ambient + (1.0 - shadow) * (diffuse + specular)) * light.Intensity;
}