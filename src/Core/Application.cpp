#include "Core/Application.hpp"
#include "Base/Pointers.hpp"
#include "Core/Platform.hpp"
#include "Core/Window.hpp"
#include "Core/WindowManager.hpp"
#include "Debug/Macros.hpp"
#include "Events/EventManager.hpp"

namespace Krys
{
  Application::Application(Unique<ApplicationContext> context) noexcept : _context(std::move(context))
  {
    KRYS_ASSERT(_context, "Application context is null");
    KRYS_ASSERT(_context->GetWindowManager(), "Window manager is null");
    KRYS_ASSERT(_context->GetInputManager(), "Input manager is null");
    KRYS_ASSERT(_context->GetEventManager(), "Event manager is null");
    KRYS_ASSERT(_context->GetGraphicsContext(), "Graphics context is null");
    KRYS_ASSERT(_context->GetRenderer(), "Renderer is null");
    KRYS_ASSERT(_context->GetMeshManager(), "Mesh manager is null");

    const ApplicationSettings &settings = _context->GetSettings();
    KRYS_ASSERT(settings.VSync || settings.RenderFrameRate > 0,
                "FPS must be greater than 0 if VSync is disabled");
    KRYS_ASSERT(settings.PhysicsFrameRate > 0, "Physics FPS must be greater than 0");

    _context->GetWindowManager()->Create(settings);
    _context->GetGraphicsContext()->Init();
    _context->GetRenderer()->Init();
  }

  void Application::Run() noexcept
  {
    OnInit();
    {
      _running = true;

      float elapsedMs = 0;
      float accumulatedMs = 0;
      while (_running)
      {
        KRYS_SCOPED_PROFILER("Frame");

        const int64 startCounter = Platform::GetTicks();
        auto window = _context->GetWindowManager()->GetCurrentWindow();
        {
          // Poll window events and input devices.
          window->Poll();
          _context->GetInputManager()->PollDevices();

          // Process events, including those just generated by input devices.
          _context->GetEventManager()->ProcessEvents();

          // Fixed update loop.
          const auto physicsStepMs = 1'000.0f / _context->GetSettings().PhysicsFrameRate;
          while (accumulatedMs >= physicsStepMs)
          {
            OnFixedUpdate(physicsStepMs / 1'000.0f);
            accumulatedMs -= physicsStepMs;
          }

          // Per-frame update and render.
          OnUpdate(static_cast<float>(elapsedMs) / 1'000.0f);
          OnRender();

          // Swap buffers to display the rendered frame.
          window->SwapBuffers();
        }

        // We'll only manually cap the frame rate if vsync is disabled.
        if (!window->IsVSyncEnabled())
        {
          // CPU friendly way to cap the frame rate that we render at.
          const float targetFrameTimeMs = 1'000.0f / window->GetRenderFrameRate();
          while (elapsedMs < targetFrameTimeMs - 2)
          {
            Platform::Sleep(1);
            elapsedMs = Platform::TicksToMilliseconds(Platform::GetTicks() - startCounter);
          }

          // Yield the thread to the OS for the remaining time, avoids busy waiting.
          do
          {
            std::this_thread::yield();
            elapsedMs = Platform::TicksToMilliseconds(Platform::GetTicks() - startCounter);
          } while (elapsedMs < targetFrameTimeMs);
        }

        // Calculate the elapsed time since the last frame.
        elapsedMs = Platform::TicksToMilliseconds(Platform::GetTicks() - startCounter);
        accumulatedMs += elapsedMs;
      }
    }
    OnShutdown();
  }

#pragma region Lifecycle Methods

  void Application::OnInit() noexcept
  {
  }

  void Application::OnUpdate(float) noexcept
  {
  }

  void Application::OnFixedUpdate(float) noexcept
  {
  }

  void Application::OnRender() noexcept
  {
  }

  void Application::OnShutdown() noexcept
  {
  }

#pragma endregion
}