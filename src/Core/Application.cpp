#include "Core/Application.hpp"
#include "Base/Pointers.hpp"
#include "Core/Debug/Macros.hpp"
#include "Core/Events/EventManager.hpp"
#include "Core/Platform.hpp"
#include "Core/Window.hpp"
#include "Core/WindowManager.hpp"

namespace Krys
{
  Application::Application(Unique<ApplicationContext> context) noexcept : _context(std::move(context))
  {
    KRYS_ASSERT(_context, "Application context is null");
    KRYS_ASSERT(_context->GetWindowManager(), "Window manager is null");
    KRYS_ASSERT(_context->GetInputManager(), "Input manager is null");
    KRYS_ASSERT(_context->GetEventManager(), "Event manager is null");

    const ApplicationSettings &settings = _context->GetSettings();
    KRYS_ASSERT(settings.VSync || settings.RenderFrameRate > 0,
                "FPS must be greater than 0 if VSync is disabled");
    _context->GetWindowManager()->Create(settings);
  }

  void Application::Run() noexcept
  {
    _running = true;

    float elapsedMs = 0;
    float accumulatedMs = 0;
    while (_running)
    {
      KRYS_SCOPED_PROFILER("Application::Tick");

      const int64 startCounter = Platform::GetTicks();
      auto window = _context->GetWindowManager()->GetCurrentWindow();
      {
        // Poll window events and input devices.
        window->Poll();
        _context->GetInputManager()->PollDevices();

        // Process events, including those just generated by input devices.
        _context->GetEventManager()->ProcessEvents();

        // Calculate the elapsed time since the last frame.
        elapsedMs = Platform::TicksToMilliseconds(Platform::GetTicks() - startCounter);
        accumulatedMs += elapsedMs;

        // Fixed update loop.
        const auto physicsStepMs = 1'000.0f / _context->GetSettings().PhysicsFrameRate;
        while (accumulatedMs >= physicsStepMs)
        {
          FixedUpdate(physicsStepMs);
          accumulatedMs -= physicsStepMs;
        }

        // Per-frame update and render.
        Update(static_cast<float>(elapsedMs));
        Render();

        // Swap buffers to display the rendered frame.
        window->SwapBuffers();
      }

      // We'll manually cap the frame rate if vsync is disabled.
      if (window->IsVSyncEnabled())
        continue;

      // CPU friendly way to cap the frame rate that we render at.
      const float targetFrameTimeMs = 1'000.0f / window->GetRenderFrameRate();
      while (elapsedMs < targetFrameTimeMs - 2)
      {
        Platform::Sleep(1);
        elapsedMs = Platform::TicksToMilliseconds(Platform::GetTicks() - startCounter);
      }

      // Yield the thread to the OS for the remaining time, avoids busy waiting.
      do
      {
        std::this_thread::yield();
        elapsedMs = Platform::TicksToMilliseconds(Platform::GetTicks() - startCounter);
      } while (elapsedMs < targetFrameTimeMs);
    }
  }
}